package io.phoenix.factory;

import io.fabric8.kubernetes.api.model.*;
import io.fabric8.kubernetes.client.KubernetesClient;
import io.phoenix.KubeApplication;
import org.jboss.logging.Logger;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static io.phoenix.util.KubeUtil.*;

public class KubernetesService implements KubernetesResource {
    private static final Logger log = Logger.getLogger(KubernetesDeployment.class);
    private final KubernetesClient client;
    private final Service serviceConfig;
    private final KubeApplication resource;

    public KubernetesService(KubeApplication resource, KubernetesClient client) {
        this.client = client;
        this.serviceConfig = resource.getSpec().getServiceConfig();
        this.resource = resource;
    }

    private void nullifyMetadataFields(ObjectMeta metadata) {
        if (metadata != null) {
            metadata.setManagedFields(new ArrayList<>());
            metadata.setCreationTimestamp(null);
            metadata.setUid(null);
            metadata.setDeletionTimestamp(null);
            metadata.setResourceVersion(null);
            metadata.setSelfLink(null);
            metadata.setGeneration(null);
        }
    }

    private void removeAutoGeneratedAnnotations(Map<String, String> annotations, String... keys) {
        if (annotations != null) {
            for (String key : keys) {
                annotations.remove(key);
            }
        }
    }

    private Service removeGeneratedFields(Service service) {
        // Nullify generated fields in metadata
        nullifyMetadataFields(service.getMetadata());

        // Remove auto-generated annotations from metadata
        removeAutoGeneratedAnnotations(service.getMetadata().getAnnotations(),
                "kubectl.kubernetes.io/last-applied-configuration");

        var spec = service.getSpec();
        spec.setClusterIP(null);
        spec.setClusterIPs(new ArrayList<String>());
        spec.setIpFamilies(new ArrayList<String>());
        spec.setIpFamilyPolicy(null);
        spec.setHealthCheckNodePort(null);


        // Nullify the dynamically generated status
        service.setStatus(null);

        return service;
    }

    private Service populateDefaultFields(Service service) {
        var spec = service.getSpec();

        // Set default fields if they are not present
        //spec.setClusterIP(defaultIfNull(spec.getClusterIP(), "None"));
        spec.setSessionAffinity(defaultIfNull(spec.getSessionAffinity(), "None"));
        spec.setType(defaultIfNull(spec.getType(), "ClusterIP"));
        spec.setInternalTrafficPolicy(defaultIfNull(spec.getInternalTrafficPolicy(), "Cluster"));
        // Populate type-specific defaults
        switch (spec.getType()) {
            case "ClusterIP":
                // Ensure cluster-specific defaults are set
                spec.setClusterIPs(defaultIfNull(spec.getClusterIPs(), new ArrayList<>()));
                break;
            case "NodePort":
                // Ensure NodePort-specific defaults
                spec.setExternalTrafficPolicy(defaultIfNull(spec.getExternalTrafficPolicy(), "Cluster"));
                break;
            case "LoadBalancer":
                // Ensure LoadBalancer-specific defaults
                spec.setLoadBalancerIP(defaultIfNull(spec.getLoadBalancerIP(), null));
                spec.setExternalIPs(defaultIfNull(spec.getExternalIPs(), new ArrayList<>()));
                spec.setLoadBalancerSourceRanges(defaultIfNull(spec.getLoadBalancerSourceRanges(), new ArrayList<>()));
                break;
            default:
                break;
        }

        // Set default selectors and ports if absent
        if (spec.getSelector() == null) {
            spec.setSelector(new HashMap<>());
        }

        if (spec.getPorts() == null) {
            spec.setPorts(new ArrayList<>());
        }

        return service;
    }

    private <T> T defaultIfNull(T value, T defaultValue) {
        return value == null ? defaultValue : value;
    }

    private boolean isDesiredStateEqual(Service serviceManifest) {
        // Fetch the existing service from the cluster
        var existingService = client.services()
                .inNamespace(serviceConfig.getMetadata().getNamespace())
                .withName(serviceConfig.getMetadata().getName())
                .get();

        if (existingService == null) {
            return false;
        }
        // Remove generated fields and populate default fields for comparison
        var finalExistingService = removeGeneratedFields(existingService);
        var finalNewService = populateDefaultFields(serviceManifest);
        return finalExistingService.equals(finalNewService);
    }

    @Override
    public boolean apply() {
        // Create the Service manifest
        var serviceManifest = new ServiceBuilder()
                .withSpec(serviceConfig.getSpec())
                .withMetadata(updateMetadata(serviceConfig.getMetadata(), this.resource))
                .build();

        serviceManifest.getMetadata().setOwnerReferences((getOwnerRef(resource)));
        log.infof("Checking desired state for deployment: %s in namespace: %s",
                serviceManifest.getMetadata().getName(),
                serviceManifest.getMetadata().getNamespace());
        // Compare the desired state with the existing state
        if (!isDesiredStateEqual(serviceManifest)) {
            // Apply the updated service configuration if states differ
            log.infof("Service state differs for %s. Updating...", serviceManifest.getMetadata().getName());
            var service = client.services().resource(serviceManifest);
            service.forceConflicts().serverSideApply();
            return waitForReadiness(service::isReady, "Service creation is in progress", resource, client, 30000);
        }

        log.infof("Service state matches for %s; no changes needed.", serviceManifest.getMetadata().getName());
        return true; // No changes needed
    }
}
